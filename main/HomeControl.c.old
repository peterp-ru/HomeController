#include <sys/param.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/timers.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "esp_spiffs.h"
#include "esp_vfs.h"
#include "esp_http_server.h"
#include "esp_chip_info.h"
#include "nvs_flash.h"
#include "esp_wifi.h"
#include "esp_sntp.h"
#include "esp_ota_ops.h"
#include "esp_app_format.h"
#include "esp_check.h"
#include "onewire_bus.h"
#include "ds18x20.h"
#include "sys/socket.h"

static const char *TAG = "HC_dev";

#define BLINK_GPIO GPIO_NUM_2
#define hc_sayStatusPeriod 2000
#define HC_ReadTemperaturePeriod 7000
#define HC_MaxWIFIReconnectAttempts 10
#define HC_STATUS_BIT_WIFI BIT0
#define HC_STATUS_BIT_HTTP BIT1
#define HC_STATUS_BIT_1820 BIT2
#define HC_STATUS_BIT_OTA  BIT6
#define HC_STATUS_BIT_INIT BIT7
// Define inverted control level
#define HC_CONTROLLEVEL_LO 1
#define HC_CONTROLLEVEL_HI 0

#define GPIO_ONE_WIRE GPIO_NUM_33
#define MAX_DEVICES 8

#define MAC_ADDR_SIZE 6
#define SCRATCH_BUFSIZE  8192
/* Max size of an individual file. Make sure this
 * value is same as that set in upload_script.html */
#define MAX_FILE_SIZE   (200*1024) // 200 KB
#define MAX_FILE_SIZE_STR "200KB"
/* Max length a file path can have on storage */
#define FILE_PATH_MAX (ESP_VFS_PATH_MAX + CONFIG_SPIFFS_OBJ_NAME_LEN)
#define IS_FILE_EXT(filename, ext) \
    (strcasecmp(&filename[strlen(filename) - sizeof(ext) + 1], ext) == 0)
// #define HTTPD_CONN_CLOSE_HEADER true
// #define HC_SHOWLOG true

struct file_server_data {
    /* Base path of file storage */
    char base_path[ESP_VFS_PATH_MAX + 1];
    /* Scratch buffer for temporary storage during file transfer */
    char scratch[SCRATCH_BUFSIZE];
};

typedef struct SystemInfoDataT {
    time_t StartupTime;
    uint8_t MacAddress[MAC_ADDR_SIZE];
    const char *HostName;
    uint32_t PartRunnAddr;
    uint32_t PartConfAddr;
    char RunningVersion[32];
    char InvalidVersion[32];
    char ProjectName[32];
} SystemInfoDataT;

typedef struct DSDataT {
    char *dsName;
    ds18x20_device_handle_t DSDevice;
    onewire_device_address_t DSAddress;
    float LastValue;
    time_t LastRead;
    uint8_t NumberOfErrors;
    bool ReadError;
} DSDataT;

typedef struct DSDataT * DSDataHandleT;

typedef struct ControlOutputDataT {
    char *coName;
    gpio_num_t gpioPin;
    time_t DayStartTimeInSec;
    time_t DayStopTimeInSec;
    DSDataHandleT Thermometr;
    float DayMinTemp;
    float DayMaxTemp;
    float NigthMinTemp;
    float NigthMaxTemp;
    int CurrentCondition;
} ControlOutputDataT;

typedef struct ControlOutputDataT * ControlOutputDataHandleT;

typedef struct HCRingbufferDefinition {
    uint8_t *mBuffer;
    size_t mSize;
    size_t mHead;
    size_t mTail;
    size_t mFree;
} HCRingbufferT;

esp_err_t hc_CurrentError=ESP_OK;
uint8_t hc_Status=0xC3;
uint8_t num_devices = 0;
uint8_t NotFoundSensorCount = 0;
uint8_t ConfiguredControls = 0;
ControlOutputDataHandleT ControlOutputData[MAX_DEVICES];
DSDataHandleT DSDevices[MAX_DEVICES];

static esp_netif_t *NetworkInterface;
static struct file_server_data *server_data = NULL;
static httpd_handle_t HCHTTPServer = NULL;
const char *SpiffsBasePath = "/data";
const char *FileManagerPrefix = "/FileManager";
const char *HTMLPageStart = "<!DOCTYPE html><html lang=\"en\"><head><meta charset=\"utf-8\"/>"
    "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">";
TaskHandle_t TaskSayStatusHandle = NULL;
TaskHandle_t TemperatureReaderHandle = NULL;
TimerHandle_t WifiReconnectTimer = NULL;
static int NumberAttempt = 0;
struct SystemInfoDataT SystemInfoData;
static onewire_bus_handle_t OWBus;
static onewire_bus_config_t OWBus_config = {
    .bus_gpio_num = GPIO_ONE_WIRE,
};
static onewire_bus_rmt_config_t OWRmt_config = {
    .max_rx_bytes = 10, // 1byte ROM command + 8byte ROM number + 1byte device command
};

const gpio_num_t OutputGPIO[MAX_DEVICES]={GPIO_NUM_18,GPIO_NUM_19,GPIO_NUM_21,GPIO_NUM_22,GPIO_NUM_23,GPIO_NUM_25,GPIO_NUM_26,GPIO_NUM_27};
const char *NVS_Namespace = "HC_NVSNAME";
const char *KeyConfigFile = "ConfigFileName";
const char AccessPoints[3][2][16] = {{"PeterHome", "PeterHomeWiFi"}, {"Galnevo24", "Galnevo24WiFi"}, {"Realme-6s", "1319e007813a"}};
HCRingbufferT HCLogBuffer;
vprintf_like_t LogFuncOriginal= NULL;
SemaphoreHandle_t ControlDSData_mux = NULL;
SemaphoreHandle_t RingBuffer_mux = NULL;
const uint16_t SemMaxWaitTime = 3000; // in miliseconds
char *ConfigFileName;

void ClearConfiguredDevices(){
    for (int i = 0; i < num_devices; i++){
        if (DSDevices[i]->dsName) free(DSDevices[i]->dsName);
        ds18x20_del_device(DSDevices[i]->DSDevice);
        free(DSDevices[i]);
    } 
    num_devices = 0;

}

esp_err_t SearchOWDevices(onewire_bus_handle_t bus){
    onewire_device_iter_handle_t iter = NULL;
    onewire_device_t next_onewire_device;
    esp_err_t search_result = ESP_OK;
    xSemaphoreTake(ControlDSData_mux, portMAX_DELAY);
    ClearConfiguredDevices();
    ds18x20_device_handle_t DS18x20device;
    // Stable readings from devices DS1820 require a brief period before communication
    // vTaskDelay(hc_sayStatusPeriod * 2 / portTICK_PERIOD_MS);
    // create 1-wire device iterator, which is used for device search
    if (onewire_new_device_iter(bus, &iter) != ESP_OK) {
        ESP_LOGE(TAG, "Fatal error. Cannot create 1-wire device iterator");
        xSemaphoreGive(ControlDSData_mux);
        return ESP_ERR_NO_MEM;
    }
    ESP_ERROR_CHECK(onewire_new_device_iter(bus, &iter));
    ESP_LOGI(TAG, "Device iterator created, start searching...");
    uint8_t FindAttemptCount = 0;
    do {
        search_result = onewire_device_iter_get_next(iter, &next_onewire_device);
        if (search_result == ESP_OK) { // found a new device, let's check if we can upgrade it to a DS18B20
            ds18x20_config_t ds_cfg = {};
            if (ds18x20_new_device(&next_onewire_device, &ds_cfg, &DS18x20device) == ESP_OK) {
                ESP_LOGI(TAG, "Found a DS18x20[%d], address: %016llX", num_devices, next_onewire_device.address);
                DSDevices[num_devices] = malloc(sizeof(DSDataT));
                if (!DSDevices[num_devices]) {
                    ds18x20_del_device(DS18x20device);
                    ESP_LOGE(TAG, "Fatal error. No mem for DS18X20 data. DS18x20[%d], address: %016llX", 
                        num_devices, next_onewire_device.address);
                    xSemaphoreGive(ControlDSData_mux);
                    return ESP_ERR_NO_MEM;
                }
                DSDevices[num_devices]->dsName = NULL;
                DSDevices[num_devices]->DSDevice = DS18x20device;
                DSDevices[num_devices]->DSAddress = next_onewire_device.address;
                DSDevices[num_devices]->NumberOfErrors = 0;
                num_devices++;
                if (num_devices >= MAX_DEVICES) {
                    ESP_LOGW(TAG, "Max DS18x20 number reached, stop searching...");
                    break;
                }
            } else {
                ESP_LOGW(TAG, "Found an unknown device, address: %016llX", next_onewire_device.address);
            }
        }
        FindAttemptCount++;
    } while (search_result != ESP_ERR_NOT_FOUND || FindAttemptCount <= MAX_DEVICES + 1);
    if (onewire_del_device_iter(iter) != ESP_OK) ESP_LOGW(TAG, "Error while onewire_del_device_iter(iter) call");
    ESP_LOGI(TAG, "Searching done, %d DS18x20 device(s) found", num_devices);
    // Set resolution for all DS1820s
    for (int i = 0; i < num_devices; i++) {
        if(ds18x20_set_resolution(DSDevices[i]->DSDevice, DS18B20_RESOLUTION_9B) != ESP_OK) {
            ESP_LOGW(TAG, "Set resolution error. DS18x20[%d], address: %016llX", i, DSDevices[i]->DSAddress);
        }
    }
    xSemaphoreGive(ControlDSData_mux);
    return ESP_OK;

}

gpio_num_t FindPin(int PinNumber){
    for (int i=0; i<MAX_DEVICES; i++) {
        if (PinNumber == (int)OutputGPIO[i]) return OutputGPIO[i];
    }
    return GPIO_NUM_NC;

}

DSDataHandleT FindThermometr(unsigned long long DSAddress, char *coName){
    for (int i=0; i<num_devices; i++) {
        if (DSAddress == DSDevices[i]->DSAddress) {
            if (DSDevices[i]->dsName == NULL) {
                DSDevices[i]->dsName = strdup(coName);
            }
            return DSDevices[i];
        }
    }
    return NULL;

}

void ClearConfiguredControls(){
    for (int i = 0; i < ConfiguredControls; i++){
        gpio_set_level(ControlOutputData[i]->gpioPin, HC_CONTROLLEVEL_LO);
        if (ControlOutputData[i]->coName) free(ControlOutputData[i]->coName);
        free(ControlOutputData[i]);
    } 
    ConfiguredControls = 0;
    NotFoundSensorCount = 0;

}

esp_err_t LoadControlConfig(char *FileName){
    const int MaxStringLength = 180;
    const char Delimiters[3]=" \t";
    const int MaxColumn = 9;
    char BufferStr[MaxStringLength];
    char *SingleWord;
    int i;
    int LineCount = 0;
    int mHour;
    int mMinute;
    ControlOutputDataT LineData;
    if (num_devices > 0)
        ESP_LOGI(TAG, "Clearing & new search for sensors. Current count of sensors: %d", num_devices);
    if(SearchOWDevices(OWBus) != ESP_OK){
        ESP_LOGW(TAG, "Error searching sensors.");
    }
    ESP_LOGI(TAG, "Loading configuration from file %s. Current controls: %d", FileName, ConfiguredControls);
    xSemaphoreTake(ControlDSData_mux, portMAX_DELAY);
    ClearConfiguredControls();
    FILE *ConfigFile = fopen(FileName, "r");
    if (ConfigFile == NULL) {
        ESP_LOGI(TAG, "Cannot open file %s", FileName);
        xSemaphoreGive(ControlDSData_mux);
        return ESP_ERR_NOT_FOUND;
    }
    while (fgets(BufferStr, MaxStringLength, ConfigFile)){
        LineCount++;
        if (strlen(BufferStr) >= MaxStringLength - 1) {
            ESP_LOGW(TAG, "Line %d too long. Ignored.", LineCount);
            continue;
        }
        if (LineCount > 20){
            ESP_LOGW(TAG, "Line limit (20) reached. Load aborted.");
            break;
        }
        SingleWord = strchr(BufferStr, '#');
        if(SingleWord != NULL) SingleWord[0] = '\0';
        SingleWord = strtok(BufferStr, Delimiters);
        for (i=0; i < MaxColumn; i++) {
            if (SingleWord == NULL) break;
            switch (i) {
                case 0:
                    LineData.coName = strdup(SingleWord);
                    break;
                case 1:
                    LineData.gpioPin = FindPin(atoi(SingleWord)); 
                    break;
                case 2:
                    LineData.Thermometr = FindThermometr(strtoull(SingleWord, NULL, 16), LineData.coName);
                    break;
                case 3:
                    sscanf(SingleWord, "%2d:%2d", &mHour, &mMinute);
                    LineData.DayStartTimeInSec = mHour * 3600 + mMinute * 60;
                    break;
                case 4:
                    sscanf(SingleWord, "%2d:%2d", &mHour, &mMinute);
                    LineData.DayStopTimeInSec = mHour * 3600 + mMinute * 60;
                    break;
                case 5:
                    LineData.DayMinTemp = strtof(SingleWord, NULL);
                    break;
                case 6:
                    LineData.DayMaxTemp = strtof(SingleWord, NULL);
                    break;
                case 7:
                    LineData.NigthMinTemp = strtof(SingleWord, NULL);
                    break;
                case 8:
                    LineData.NigthMaxTemp = strtof(SingleWord, NULL);
                    break;
            }
            SingleWord = strtok(NULL, Delimiters);
        }
        // skip empty lines
        if (i == 0) continue;
        // Check for error 
        if (i != MaxColumn
            || LineData.gpioPin == GPIO_NUM_NC
            || LineData.gpioPin == GPIO_NUM_0
            || LineData.DayStartTimeInSec >= LineData.DayStopTimeInSec
            || LineData.DayMinTemp == LineData.DayMaxTemp
            || LineData.NigthMinTemp == LineData.NigthMaxTemp){
            ESP_LOGI(TAG, "Data error in line %d column %d. Ignored.", LineCount, i);
        } else if (LineData.Thermometr == NULL) {
            NotFoundSensorCount++;
            ESP_LOGI(TAG, "Sensor not found in line %d. Ignored.", LineCount);
        } else {
            if (ConfiguredControls < MAX_DEVICES) {
                LineData.CurrentCondition = HC_CONTROLLEVEL_LO; // on startup always LO
                ControlOutputData[ConfiguredControls] = malloc(sizeof(ControlOutputDataT));
                if (ControlOutputData[ConfiguredControls]) {
                    memcpy(ControlOutputData[ConfiguredControls], &LineData, sizeof(ControlOutputDataT));
                    ConfiguredControls++;
                    ESP_LOGI(TAG, "Added control %d in condition LO", LineData.gpioPin);
                } else {
                    fclose(ConfigFile);
                    xSemaphoreGive(ControlDSData_mux);
                    ESP_RETURN_ON_FALSE(false, ESP_ERR_NO_MEM, TAG, "no mem for ControlOutputData data");
                }
            } else {
                fclose(ConfigFile);
                xSemaphoreGive(ControlDSData_mux);
                ESP_RETURN_ON_FALSE(false, ESP_ERR_NOT_SUPPORTED, TAG, "Maximum number of controls reached. Abort reading.");
            }
        }
    }
    fclose(ConfigFile);
    xSemaphoreGive(ControlDSData_mux);
    ESP_LOGI(TAG, "Configured %d controls. Not found sensor count: %d.", ConfiguredControls, NotFoundSensorCount);
    return ESP_OK;

}

bool SwitchControlOutput(ControlOutputDataHandleT ControlData, time_t CurrenTimeInSec, float CurrentTemp, bool TempError){
    int8_t Action = -1;
    // Switching
    if (CurrenTimeInSec >= ControlData->DayStartTimeInSec && CurrenTimeInSec < ControlData->DayStopTimeInSec){ 
        if (!TempError && CurrentTemp < ControlData->DayMinTemp && ControlData->CurrentCondition == HC_CONTROLLEVEL_LO) 
            Action = HC_CONTROLLEVEL_HI;
        else if (!TempError && CurrentTemp >= ControlData->DayMaxTemp && ControlData->CurrentCondition == HC_CONTROLLEVEL_HI)
            Action = HC_CONTROLLEVEL_LO;
    } else {
        if (!TempError && CurrentTemp < ControlData->NigthMinTemp && ControlData->CurrentCondition == HC_CONTROLLEVEL_LO)
            Action = HC_CONTROLLEVEL_HI;
        else if (!TempError && CurrentTemp >= ControlData->NigthMaxTemp && ControlData->CurrentCondition == HC_CONTROLLEVEL_HI)
            Action = HC_CONTROLLEVEL_LO;
    }
    if (Action != -1) {
        gpio_set_level(ControlData->gpioPin, Action);
        ESP_LOGI(TAG, "Control %d switched from %s to %s", ControlData->gpioPin, 
            ControlData->CurrentCondition == HC_CONTROLLEVEL_HI ? "HI" : "LO", 
            Action == HC_CONTROLLEVEL_HI ? "HI" : "LO");
        ControlData->CurrentCondition = Action;
        return true;
    } else return false;

}

void SwitchAllControl(void){
    time_t now;
    struct tm* tmCurrentTime;
    float CurrentTemp = 0;
    bool TempInError;
    time(&now);
    tmCurrentTime = localtime(&now);
    // Convert to time only
    time_t CurrenTimeInSec = tmCurrentTime->tm_hour * 3600 + tmCurrentTime->tm_min * 60 + tmCurrentTime->tm_sec;
    for (uint8_t i=0; i < ConfiguredControls; i++){
        // take current temp
        if (ControlOutputData[i]->Thermometr != NULL) {
            CurrentTemp = ControlOutputData[i]->Thermometr->LastValue;
            TempInError = ControlOutputData[i]->Thermometr->ReadError;
        } else TempInError = true;
        if (SwitchControlOutput(ControlOutputData[i], CurrenTimeInSec, CurrentTemp, TempInError)) break;
    }

}

void ReadTemperatures(void *VoidParam) {
    bool GotError;
    float temperature;
    bool NeedReload;
    time_t now;
    while (true) {
        if (xSemaphoreTake(ControlDSData_mux, SemMaxWaitTime / portTICK_PERIOD_MS)) {
            NeedReload = false;
            for (int i = 0; i < num_devices; i ++) {
                GotError = true;
                NeedReload = NeedReload || DSDevices[i]->NumberOfErrors == 255;
                if (ds18x20_trigger_temperature_conversion(DSDevices[i]->DSDevice) == ESP_OK){
                    if (ds18x20_get_temperature(DSDevices[i]->DSDevice, &temperature) == ESP_OK){
                        time(&now);
                        DSDevices[i]->LastValue = temperature;
                        DSDevices[i]->LastRead = now;
                        DSDevices[i]->ReadError = false;
                        GotError = false;
                        ESP_LOGD(TAG, "read from DSDevices[%d]: %.2fC", i, temperature);
                    } else {
                        ESP_LOGW(TAG, "ds18x20_get_temperature error on DSDevices[%d]", i);
                    }
                } else {
                    ESP_LOGW(TAG, "ds18x20_trigger_temperature_conversion error on DSDevices[%d]", i);
                }
                if (GotError) {
                    if (DSDevices[i]->NumberOfErrors < 255) DSDevices[i]->NumberOfErrors++;
                    DSDevices[i]->ReadError = true;
                }
            }
            // start switching controls
            SwitchAllControl();
            xSemaphoreGive(ControlDSData_mux);
            if (NeedReload && ConfigFileName != NULL) LoadControlConfig(ConfigFileName);
        } else {
            ESP_LOGW(TAG, "Temperature not read! Semaphore timed out.");
        }
        vTaskDelay(HC_ReadTemperaturePeriod / portTICK_PERIOD_MS);
    }

}

void time_sync_notification_cb(struct timeval *tv){
    char strftime_buf[21];
    struct tm timeinfo;
    if (SystemInfoData.StartupTime == 0){
        time(&SystemInfoData.StartupTime);
        SystemInfoData.StartupTime = SystemInfoData.StartupTime - (int)(esp_log_timestamp()/1000);
    }
    localtime_r(&tv->tv_sec, &timeinfo);
    strftime(strftime_buf, sizeof(strftime_buf), "%d.%m.%Y %T ", &timeinfo);
    ESP_LOGI(TAG, "Time synchronization notification: %s", strftime_buf);

}

void initialize_sntp(void){
    setenv("TZ","MSK-3",1);
    tzset();
    esp_sntp_setoperatingmode(ESP_SNTP_OPMODE_POLL);
    esp_sntp_setservername(0, "pool.ntp.org");
    sntp_set_time_sync_notification_cb(time_sync_notification_cb);
    esp_sntp_init();
}

static void vRestartCallback(TimerHandle_t tmr){
    esp_restart();

}

esp_err_t RingBufferCreate(HCRingbufferT *Buffer, size_t Size){
    if (xSemaphoreTake(RingBuffer_mux, SemMaxWaitTime / portTICK_PERIOD_MS) == pdFALSE) return ESP_ERR_TIMEOUT;
    Buffer->mBuffer = malloc(Size);
    if (Buffer->mBuffer == NULL) return ESP_ERR_NO_MEM;
    Buffer->mSize = Size;
    Buffer->mHead = 0;
    Buffer->mTail = 0;
    Buffer->mFree = Size;
    xSemaphoreGive(RingBuffer_mux);
    return ESP_OK;

}

esp_err_t RingBufferDestroy(HCRingbufferT *Buffer){
    if (xSemaphoreTake(RingBuffer_mux, SemMaxWaitTime / portTICK_PERIOD_MS) == pdFALSE) return ESP_ERR_TIMEOUT;
    if (Buffer->mBuffer) {
        free(Buffer->mBuffer);
        Buffer->mBuffer = NULL;
        Buffer->mSize = 0;
        Buffer->mFree = 0;
    }
    xSemaphoreGive(RingBuffer_mux);
    return ESP_OK;  

}

size_t RingBufferPut(HCRingbufferT *Buffer, const char *pvItem, size_t mItemSize){
    if (xSemaphoreTake(RingBuffer_mux, SemMaxWaitTime / portTICK_PERIOD_MS) == pdFALSE) return ESP_ERR_TIMEOUT;
    if (mItemSize > Buffer->mSize) {
        xSemaphoreGive(RingBuffer_mux);
        return 0;
    }
    if (Buffer->mSize - Buffer->mTail >= mItemSize){ 
        memcpy(Buffer->mTail + Buffer->mBuffer, pvItem, mItemSize);
        Buffer->mTail += mItemSize;
    } else {
        size_t FirstPart = Buffer->mSize - Buffer->mTail;
        size_t SecondPart = mItemSize - FirstPart;
        if (FirstPart > 0) memcpy(Buffer->mTail + Buffer->mBuffer, pvItem, FirstPart);
        memcpy(Buffer->mBuffer, pvItem + FirstPart, SecondPart);
        Buffer->mTail = SecondPart;
    }
    if (Buffer->mFree > mItemSize){
        Buffer->mFree -= mItemSize;
    } else {
        Buffer->mFree = 0;
        Buffer->mHead = Buffer->mTail;
    }
    xSemaphoreGive(RingBuffer_mux);
    return mItemSize;

}

size_t RingBufferGet(HCRingbufferT *Buffer, char *pvItem, size_t mItemSize){
    if (xSemaphoreTake(RingBuffer_mux, SemMaxWaitTime / portTICK_PERIOD_MS) == pdFALSE) return ESP_ERR_TIMEOUT;
    if (mItemSize > Buffer->mSize - Buffer->mFree) mItemSize = Buffer->mSize - Buffer->mFree;
    if (mItemSize == 0) {
        xSemaphoreGive(RingBuffer_mux);
        return 0; 
    }
    if (Buffer->mSize - Buffer->mHead >= mItemSize){ 
        memcpy(pvItem, Buffer->mBuffer + Buffer->mHead, mItemSize);
        Buffer->mHead += mItemSize;
    } else {
        size_t FirstPart = Buffer->mSize - Buffer->mHead;
        size_t SecondPart = mItemSize - FirstPart;
        if (FirstPart > 0) memcpy(pvItem, Buffer->mBuffer + Buffer->mHead, FirstPart);
        memcpy(pvItem + FirstPart, Buffer->mBuffer, SecondPart);
        Buffer->mHead = SecondPart;
    }
    Buffer->mFree += mItemSize;
    xSemaphoreGive(RingBuffer_mux);
    return mItemSize;

}

void FinalizeHTTPPage(httpd_req_t *req){
#ifdef HTTPD_CONN_CLOSE_HEADER
    httpd_resp_set_hdr(req, "Connection", "close");
#endif
    httpd_resp_send_chunk(req, NULL, 0);

}

void SendStartOfHTTPPage(httpd_req_t *req, const char *StartStr){
    httpd_resp_set_type(req, "text/html; charset=utf-8");
    httpd_resp_set_hdr(req, "X-Content-Type-Options", "nosniff");
    httpd_resp_set_hdr(req, "Cache-Control", "no-cache");
    httpd_resp_sendstr_chunk(req, StartStr);

}

static esp_err_t GetLogPageHandler(httpd_req_t *req){
    httpd_resp_set_type(req, "text/plain");   
    size_t tmpBufferSize = 0x7FF; //2K 0x1FFF; // 8K
    size_t Getted;
    char *tmpBuffer = malloc(tmpBufferSize); 
    if (tmpBuffer == NULL) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to send log file, no memory");
        return ESP_ERR_NO_MEM;
    }
    do {
        Getted = RingBufferGet(&HCLogBuffer, tmpBuffer, tmpBufferSize);
        if (Getted > 0 ){
            // Send the buffer contents as HTTP response chunk 
            if (httpd_resp_send_chunk(req, tmpBuffer, Getted) != ESP_OK) {
                httpd_resp_sendstr_chunk(req, NULL);
                httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to send log file");
                free(tmpBuffer);
                return ESP_FAIL;
           }
        }
    } while (Getted == tmpBufferSize);
    free(tmpBuffer);
    FinalizeHTTPPage(req);
    return ESP_OK;

}

static esp_err_t ConfigurationPageHandler(httpd_req_t *req){
    const int HourInSec = 3600;
    char *tmpStr;
    char tmpBuf[140];
    uint16_t mHour;
    uint16_t mMinute;
    onewire_device_address_t mAddress;
    SendStartOfHTTPPage(req, HTMLPageStart);
    httpd_resp_sendstr_chunk(req, "<title>ESP-32 device</title></head><body><h2>Configuration</h2><br>");
    if (ConfiguredControls > 0){
        httpd_resp_sendstr_chunk(req, "<h3>Controls informarion</h3>");
        if (xSemaphoreTake(ControlDSData_mux, SemMaxWaitTime / portTICK_PERIOD_MS)) {
            httpd_resp_sendstr_chunk(req, "<table border=\"1\"><tr><th>Name</th><th>Load</th><th>DSNumber</th>"
                "<th>DayStartTime</th><th>DayStopTime</th><th>DayMinTemp</th><th>DayMaxTemp</th>"
                "<th>NigthMinTemp</th><th>NigthMaxTemp</th></tr>");
            for (int i = 0; i < ConfiguredControls; i++){
                if (ControlOutputData[i]->coName == NULL) tmpStr = "Unnamed"; else tmpStr = ControlOutputData[i]->coName;
                if (ControlOutputData[i]->Thermometr != NULL)  mAddress = ControlOutputData[i]->Thermometr->DSAddress;
                else mAddress = 0;
                mHour = ControlOutputData[i]->DayStartTimeInSec / HourInSec;
                mMinute = (ControlOutputData[i]->DayStartTimeInSec - mHour * HourInSec) / 60;
                sprintf(tmpBuf, "<tr align = \"center\"><td>%s</td><td>%d</td><td>%016llX</td><td>%d:%d</td>", 
                    tmpStr, ControlOutputData[i]->gpioPin, mAddress, mHour, mMinute);
                httpd_resp_sendstr_chunk(req, tmpBuf);
                mHour = ControlOutputData[i]->DayStopTimeInSec / HourInSec;
                mMinute = (ControlOutputData[i]->DayStopTimeInSec - mHour * HourInSec) / 60;
                sprintf(tmpBuf, "<td>%d:%d</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td></tr>", 
                    mHour, mMinute, ControlOutputData[i]->DayMinTemp, ControlOutputData[i]->DayMaxTemp,
                    ControlOutputData[i]->NigthMinTemp, ControlOutputData[i]->NigthMaxTemp);
                httpd_resp_sendstr_chunk(req, tmpBuf);
            }
            httpd_resp_sendstr_chunk(req, "</table>");
            xSemaphoreGive(ControlDSData_mux);
        } else httpd_resp_sendstr_chunk(req, "<br>Read data failed! Semaphore timed out.");
    }
    httpd_resp_sendstr_chunk(req, "<br><table border=\"0\"><col width=\"700px\"/><tr><td><table border=\"0\"><tr>"
        "<td>Current config file:</td><td>");
    if(ConfigFileName) httpd_resp_sendstr_chunk(req, ConfigFileName);
    httpd_resp_sendstr_chunk(req, "</td></tr><tr><td><label for=\"filename\">New config file:</label></td>"
        "<td><input id=\"filename\" type=\"text\"></td></tr><tr><td><button id=\"upload\" type=\"button\" onclick"
        "=\"upload()\">Apply new Configuration</button></td></tr></table></td></tr></table>");
    /* Get handle to embedded firmware update script */
    extern const unsigned char Config_script_start[] asm("_binary_ConfigurationScript_html_start");
    extern const unsigned char Config_script_end[]   asm("_binary_ConfigurationScript_html_end");
    const size_t Config_script_size = (Config_script_end - Config_script_start);
    httpd_resp_send_chunk(req, (const char *)Config_script_start, Config_script_size);
    FinalizeHTTPPage(req);
    return ESP_OK;

}

static esp_err_t HomePageHandler(httpd_req_t *req)
{
    char tmpBuf[140];
    const char *tmpStr;
    time_t now = 0;
    struct tm timeinfo = { 0 };
    esp_chip_info_t ChipInfo;
    SendStartOfHTTPPage(req, HTMLPageStart);
    httpd_resp_sendstr_chunk(req, "<title>ESP-32 device</title>"
        "</head><body><h1>ESP-32 device</h1><h2>Home controller</h2>"
        "<h3>System information</h3><table><col width=\"150px\"/><tr><td>Current time</td><td>");
    time(&now);
    localtime_r(&now, &timeinfo);
    strftime(tmpBuf, 140, "%d.%m.%Y %X", &timeinfo);
    httpd_resp_sendstr_chunk(req, tmpBuf);
    httpd_resp_sendstr_chunk(req, "</td></tr>");

    time_t UpTime = now - SystemInfoData.StartupTime;
    int Days = (int)(UpTime / 86400);
    int Hours = (int)((UpTime - Days * 86400) / 3600);
    sprintf(tmpBuf, "<tr><td>Uptime</td><td>%d %02d:", Days, Hours);
    httpd_resp_sendstr_chunk(req, tmpBuf);
    localtime_r(&UpTime, &timeinfo);
    strftime(tmpBuf, 140, "%M:%S", &timeinfo);
    httpd_resp_sendstr_chunk(req, tmpBuf);
    httpd_resp_sendstr_chunk(req, "</td></tr>");

    sprintf(tmpBuf, "<tr><td>Heap memory</td><td>%ld</td></tr>", esp_get_free_heap_size());
    httpd_resp_sendstr_chunk(req, tmpBuf);

    httpd_resp_sendstr_chunk(req, "<tr><td>Reset reason</td><td>");
    esp_reset_reason_t LastReset = esp_reset_reason();
    if (LastReset == ESP_RST_SDIO) tmpStr="Reset over SDIO";
    else if (LastReset == ESP_RST_BROWNOUT) tmpStr="Brownout reset";
    else if (LastReset == ESP_RST_DEEPSLEEP) tmpStr="Exiting deep sleep mode";
    else if (LastReset == ESP_RST_WDT) tmpStr="Other watchdogs";
    else if (LastReset == ESP_RST_TASK_WDT) tmpStr="Task watchdog";
    else if (LastReset == ESP_RST_INT_WDT) tmpStr="Interrupt watchdog";
    else if (LastReset == ESP_RST_PANIC) tmpStr="Exception/panic";
    else if (LastReset == ESP_RST_SW) tmpStr="Software restart";
    else if (LastReset == ESP_RST_EXT) tmpStr="External pin";
    else if (LastReset == ESP_RST_POWERON) tmpStr="Power-on";
    else tmpStr="Unknown";
    httpd_resp_sendstr_chunk(req, tmpStr);
    httpd_resp_sendstr_chunk(req, "</td></tr>");

    const esp_app_desc_t *ApplicationDescr = esp_app_get_description();
    sprintf(tmpBuf, "<tr><td>Firmware name</td><td>%s</td></tr>", SystemInfoData.ProjectName);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    sprintf(tmpBuf, "<tr><td>Firmware version</td><td>%s</td></tr>", SystemInfoData.RunningVersion);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    sprintf(tmpBuf, "<tr><td>SDK version</td><td>%s</td></tr>", ApplicationDescr->idf_ver);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    sprintf(tmpBuf, "<tr><td>Host name</td><td>%s</td></tr>", SystemInfoData.HostName);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    sprintf(tmpBuf, "<tr><td>MAC address</td><td>%02x:%02x:%02x:%02x:%02x:%02x</td></tr>", 
        SystemInfoData.MacAddress[0], SystemInfoData.MacAddress[1], SystemInfoData.MacAddress[2],
        SystemInfoData.MacAddress[3], SystemInfoData.MacAddress[4], SystemInfoData.MacAddress[5]);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    esp_chip_info(&ChipInfo);
    if (ChipInfo.model == CHIP_ESP32) tmpStr="ESP32";
    else if (ChipInfo.model == CHIP_ESP32S2) tmpStr="ESP32-S2";
    else if (ChipInfo.model == CHIP_ESP32S3) tmpStr="ESP32-S3";
    else if (ChipInfo.model == CHIP_ESP32C3) tmpStr="ESP32-C3";
    else if (ChipInfo.model == CHIP_ESP32C2) tmpStr="ESP32-C2";
    else if (ChipInfo.model == CHIP_ESP32C6) tmpStr="ESP32-C6";
    else if (ChipInfo.model == CHIP_ESP32H2) tmpStr="ESP32-H2";
    else tmpStr="POSIX/Linux simulator";
    httpd_resp_sendstr_chunk(req, "<tr><td>Chip model</td><td>");
    httpd_resp_sendstr_chunk(req, tmpStr);

    httpd_resp_sendstr_chunk(req, "</td></tr>");
    sprintf(tmpBuf, "<tr><td>Chip revision number</td><td>%d.%02d</td></tr>", 
        (int)(ChipInfo.revision / 100), ChipInfo.revision - 100);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    sprintf(tmpBuf, "<tr><td>CPU cores</td><td>%d</td></tr>", ChipInfo.cores);
    httpd_resp_sendstr_chunk(req, tmpBuf);
    httpd_resp_sendstr_chunk(req, "</table>");

    if (num_devices > 0){
        httpd_resp_sendstr_chunk(req, "<h3>Temperature sensor information</h3>");
        if (xSemaphoreTake(ControlDSData_mux, SemMaxWaitTime / portTICK_PERIOD_MS)) {
            httpd_resp_sendstr_chunk(req, "<table border=\"1\"><thead><tr><th>Name</th><th>Address</th><th>Last read</th>"
                "<th>Number of errors</th><th>Value</th></tr></thead><tbody>");
            for (int i = 0; i < num_devices; i++){
                if (DSDevices[i]->dsName == NULL) tmpStr = "Unnamed"; else tmpStr = DSDevices[i]->dsName;
                localtime_r(&DSDevices[i]->LastRead, &timeinfo);
                sprintf(tmpBuf, "<tr><td>%s</td><td>%016llX</td><td>", tmpStr, DSDevices[i]->DSAddress);
                httpd_resp_sendstr_chunk(req, tmpBuf);
                strftime(tmpBuf, 140, "%d.%m.%Y %X", &timeinfo);
                httpd_resp_sendstr_chunk(req, tmpBuf);
                sprintf(tmpBuf, "</td><td>%d</td><td>%.2f</td></tr>", DSDevices[i]->NumberOfErrors, DSDevices[i]->LastValue);
                httpd_resp_sendstr_chunk(req, tmpBuf);
            }
            httpd_resp_sendstr_chunk(req, "</tbody></table>");
            xSemaphoreGive(ControlDSData_mux);
        } else httpd_resp_sendstr_chunk(req, "<br>Read data failed! Semaphore timed out.");
    }
    httpd_resp_sendstr_chunk(req, "<br><a href=\"/FileManager\">File manager</a>"
        "<br><a href=\"/FirmwareUpdate\">Firmware update</a>"
        "<br><a href=\"/Configuration\">Device configuration</a>"
        "<br><a href=\"/GetLog\">Log file</a></body></html>");
    FinalizeHTTPPage(req);
    return ESP_OK;

}

static esp_err_t FirmwareUpdateHandler(httpd_req_t *req){
    char tmpBuf[140];
    SendStartOfHTTPPage(req, HTMLPageStart);
    httpd_resp_sendstr_chunk(req, "<title>ESP-32 device</title></head><body><h2>ESP-32 Firmware update</h2>"
        "<table border=\"1\"><col width=\"200px\"/><col width=\"100px\"/>");

    sprintf(tmpBuf, "<tr><td>Running partition:</td><td align=\"right\">%ld</td></tr>", SystemInfoData.PartRunnAddr);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    sprintf(tmpBuf, "<tr><td>Boot partition:</td><td align=\"right\">%ld</td></tr>", SystemInfoData.PartConfAddr);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    httpd_resp_sendstr_chunk(req, "<tr><td colspan =\"2\">Not equal value can happen if either "
        "the OTA boot data or preferred boot image become corrupted somehow.</td></tr>");

    sprintf(tmpBuf, "<tr><td>Running firmware version:</td><td align=\"right\">%s</td></tr>", SystemInfoData.RunningVersion);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    sprintf(tmpBuf, "<tr><td>Invalid firmware version:</td><td align=\"right\">%s</td></tr>", SystemInfoData.InvalidVersion);
    httpd_resp_sendstr_chunk(req, tmpBuf);

    httpd_resp_sendstr_chunk(req, "</table>");

    /* Get handle to embedded firmware update script */
    extern const unsigned char firmware_script_start[] asm("_binary_FirmwareScript_html_start");
    extern const unsigned char firmware_script_end[]   asm("_binary_FirmwareScript_html_end");
    const size_t firmware_script_size = (firmware_script_end - firmware_script_start);
    httpd_resp_send_chunk(req, (const char *)firmware_script_start, firmware_script_size);
    FinalizeHTTPPage(req);
    return ESP_OK;

}

/* Copies the full path into destination buffer and returns
 * pointer to path (skipping the preceding base path) */
static const char* get_path_from_uri(char *dest, const char *base_path, const char *uri, size_t destsize){
    const size_t base_pathlen = strlen(base_path);
    size_t pathlen = strlen(uri);

    const char *quest = strchr(uri, '?');
    if (quest) {
        pathlen = MIN(pathlen, quest - uri);
    }
    const char *hash = strchr(uri, '#');
    if (hash) {
        pathlen = MIN(pathlen, hash - uri);
    }

    if (base_pathlen + pathlen + 1 > destsize) {
        /* Full path string won't fit into destination buffer */
        return NULL;
    }

    /* Construct full path (base + path) */
    strcpy(dest, base_path);
    strlcpy(dest + base_pathlen, uri, pathlen + 1);

    /* Return pointer to path, skipping the base */
    return dest + base_pathlen;

}

/* Send HTTP response with a run-time generated html consisting of
 * a list of all files and folders under the requested path.
 * In case of SPIFFS this returns empty list when path is any
 * string other than '/', since SPIFFS doesn't support directories */
static esp_err_t http_resp_dir_html(httpd_req_t *req, const char *dirpath){
    char entrypath[FILE_PATH_MAX];
    char entrysize[16];
    const char *entrytype;

    struct dirent *entry;
    struct stat entry_stat;

    DIR *dir = opendir(dirpath);
    const size_t dirpath_len = strlen(dirpath);

    /* Retrieve the base path of file storage to construct the full path */
    strlcpy(entrypath, dirpath, sizeof(entrypath));

    if (!dir) {
        ESP_LOGE(TAG, "Failed to stat dir : %s", dirpath);
        /* Respond with 404 Not Found */
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Directory does not exist");
        return ESP_FAIL;
    }

    /* Send HTML file header */
    SendStartOfHTTPPage(req, HTMLPageStart);
    httpd_resp_sendstr_chunk(req, "<title>ESP-32 device</title></head><body><h2>ESP-32 File Manager</h2>");

    /* Get handle to embedded file upload script */
    extern const unsigned char upload_script_start[] asm("_binary_upload_script_html_start");
    extern const unsigned char upload_script_end[]   asm("_binary_upload_script_html_end");
    const size_t upload_script_size = (upload_script_end - upload_script_start);

    /* Add file upload form and script which on execution sends a POST request to /upload */
    httpd_resp_send_chunk(req, (const char *)upload_script_start, upload_script_size);

    /* Send file-list table definition and column labels */
    httpd_resp_sendstr_chunk(req,
        "<table border=\"1\">"
        "<col width=\"300px\" /><col width=\"50px\" /><col width=\"90px\" /><col width=\"60px\" />"
        "<thead><tr><th>Name</th><th>Type</th><th>Size (Bytes)</th><th>Delete</th></tr></thead>"
        "<tbody>");

    /* Iterate over all files / folders and fetch their names and sizes */
    while ((entry = readdir(dir)) != NULL) {
        entrytype = (entry->d_type == DT_DIR ? "folder" : "file");

        strlcpy(entrypath + dirpath_len, entry->d_name, sizeof(entrypath) - dirpath_len);
        if (stat(entrypath, &entry_stat) == -1) {
            ESP_LOGE(TAG, "Failed to stat %s : %s", entrytype, entry->d_name);
            continue;
        }
        sprintf(entrysize, "%ld", entry_stat.st_size);

        /* Send chunk of HTML file containing table entries with file name and size */
        httpd_resp_sendstr_chunk(req, "<tr><td><a href=\"");
        httpd_resp_sendstr_chunk(req, req->uri);
        httpd_resp_sendstr_chunk(req, entry->d_name);
        if (entry->d_type == DT_DIR) {
            httpd_resp_sendstr_chunk(req, "/");
        }
        httpd_resp_sendstr_chunk(req, "\">");
        httpd_resp_sendstr_chunk(req, entry->d_name);
        httpd_resp_sendstr_chunk(req, "</a></td><td>");
        httpd_resp_sendstr_chunk(req, entrytype);
        httpd_resp_sendstr_chunk(req, "</td><td align=\"right\">");
        httpd_resp_sendstr_chunk(req, entrysize);
        httpd_resp_sendstr_chunk(req, "</td><td>");
        httpd_resp_sendstr_chunk(req, "<form method=\"post\" action=\"/delete");
        httpd_resp_sendstr_chunk(req, req->uri);
        httpd_resp_sendstr_chunk(req, entry->d_name);
        httpd_resp_sendstr_chunk(req, "\"><button type=\"submit\">Delete</button></form>");
        httpd_resp_sendstr_chunk(req, "</td></tr>\n");
    }
    closedir(dir);

    /* Finish the file list table */
    httpd_resp_sendstr_chunk(req, "</tbody></table>");
    /* Used and Total bytes */
    size_t total = 0, used = 0;
    esp_err_t ret = esp_spiffs_info(NULL, &total, &used);
    if (ret == ESP_OK) {
        char UsedBytes[250];
        sprintf(UsedBytes, "<br><table><tr><td>Total bytes:</td><td align=\"right\">%d</td></tr>"
            "<tr><td>Used bytes:</td><td align=\"right\">%d</td></tr><tr>"
            "<td>Free bytes:</td><td align=\"right\">%d</td></tr></table>", total, used, total - used);
        httpd_resp_sendstr_chunk(req, UsedBytes);
     }
    /* Send remaining chunk of HTML file to complete it */
    httpd_resp_sendstr_chunk(req, "<a href=\"/\">Home page</a></body></html>");
    FinalizeHTTPPage(req);
    return ESP_OK;

}

/* Handler to redirect incoming GET request for /index.html to /
 * This can be overridden by uploading file with same name */
static esp_err_t index_html_get_handler(httpd_req_t *req){
    httpd_resp_set_status(req, "307 Temporary Redirect");
    httpd_resp_set_hdr(req, "Location", "/");
    httpd_resp_send(req, NULL, 0);  // Response body can be empty
    return ESP_OK;

}

/* Handler to respond with an icon file embedded in flash.
 * Browsers expect to GET website icon at URI /favicon.ico.
 * This can be overridden by uploading file with same name */
static esp_err_t favicon_get_handler(httpd_req_t *req){
    extern const unsigned char favicon_ico_start[] asm("_binary_favicon_ico_start");
    extern const unsigned char favicon_ico_end[]   asm("_binary_favicon_ico_end");
    const size_t favicon_ico_size = (favicon_ico_end - favicon_ico_start);
    httpd_resp_set_type(req, "image/x-icon");
    httpd_resp_set_hdr(req, "X-Content-Type-Options", "nosniff");
    httpd_resp_set_hdr(req, "Cache-Control", "max-age=31536000, immutable");
    httpd_resp_send(req, (const char *)favicon_ico_start, favicon_ico_size);
    FinalizeHTTPPage(req);
    return ESP_OK;

}

/* Set HTTP response content type according to file extension */
static esp_err_t set_content_type_from_file(httpd_req_t *req, const char *filename){
    if (IS_FILE_EXT(filename, ".pdf")) {
        return httpd_resp_set_type(req, "application/pdf");
    } else if (IS_FILE_EXT(filename, ".html")) {
        return httpd_resp_set_type(req, "text/html");
    } else if (IS_FILE_EXT(filename, ".jpeg")) {
        return httpd_resp_set_type(req, "image/jpeg");
    } else if (IS_FILE_EXT(filename, ".ico")) {
        return httpd_resp_set_type(req, "image/x-icon");
    }
    /* This is a limited set only */
    /* For any other type always set as plain text */
    return httpd_resp_set_type(req, "text/plain");

}

static esp_err_t download_get_handler(httpd_req_t *req){
    const char *FirmwareUpdatePrefix = "/FirmwareUpdate";
    const char *ConfigurationPrefix = "/Configuration";
    const char *GetLogPrefix = "/GetLog";
    char filepath[FILE_PATH_MAX];
    FILE *fd = NULL;
    struct stat file_stat;

    if (req->uri[strlen(req->uri) - 1] == '/') {
        return HomePageHandler(req);
    }

    char *PosFM = strstr(req->uri, FirmwareUpdatePrefix);
    if (PosFM != NULL) {
        return FirmwareUpdateHandler(req);
    }

    PosFM = strstr(req->uri, ConfigurationPrefix);
    if (PosFM != NULL) return ConfigurationPageHandler(req);

    PosFM = strstr(req->uri, GetLogPrefix);
    if (PosFM != NULL) return GetLogPageHandler(req);

    PosFM = strstr(req->uri, FileManagerPrefix);
    if (PosFM != NULL) {
        strlcpy(PosFM + 1, PosFM + strlen(FileManagerPrefix), strlen(req->uri));
    }

    const char *filename = get_path_from_uri(filepath, ((struct file_server_data *)req->user_ctx)->base_path,
                                             req->uri, sizeof(filepath));
    if (!filename) {
        ESP_LOGE(TAG, "Filename is too long");
        /* Respond with 500 Internal Server Error */
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Filename too long");
        return ESP_FAIL;
    }

    /* If name has trailing '/', respond with directory contents */
    if (filename[strlen(filename) - 1] == '/') {
        return http_resp_dir_html(req, filepath);
    }

    /* Check if URI correspond to one of the hardcoded paths */
    if (strcmp(filename, "/index.html") == 0) {
        return index_html_get_handler(req);
    } else if (strcmp(filename, "/favicon.ico") == 0) {
        return favicon_get_handler(req);
    }

    if (stat(filepath, &file_stat) == -1) {
        /* If file not present  */
        ESP_LOGE(TAG, "Failed to stat file : %s", filepath);
        /* Respond with 404 Not Found */
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Error 404 - Page not found");
        return ESP_FAIL;
    }

    fd = fopen(filepath, "r");
    if (!fd) {
        ESP_LOGE(TAG, "Failed to read existing file : %s", filepath);
        /* Respond with 500 Internal Server Error */
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to read existing file");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG, "Sending file : %s (%ld bytes)...", filename, file_stat.st_size);
    set_content_type_from_file(req, filename);

    /* Retrieve the pointer to scratch buffer for temporary storage */
    char *chunk = ((struct file_server_data *)req->user_ctx)->scratch;
    size_t chunksize;
    do {
        /* Read file in chunks into the scratch buffer */
        chunksize = fread(chunk, 1, SCRATCH_BUFSIZE, fd);

        if (chunksize > 0) {
            /* Send the buffer contents as HTTP response chunk */
            if (httpd_resp_send_chunk(req, chunk, chunksize) != ESP_OK) {
                fclose(fd);
                ESP_LOGE(TAG, "File sending failed!");
                /* Abort sending file */
                httpd_resp_sendstr_chunk(req, NULL);
                /* Respond with 500 Internal Server Error */
                httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to send file");
               return ESP_FAIL;
           }
        }

        /* Keep looping till the whole file is sent */
    } while (chunksize != 0);

    /* Close file after sending complete */
    fclose(fd);
    ESP_LOGI(TAG, "File sending complete");
    FinalizeHTTPPage(req);
    return ESP_OK;

}

/* Handler to upload a file onto the server */
static esp_err_t upload_post_handler(httpd_req_t *req){
    char filepath[FILE_PATH_MAX];
    FILE *fd = NULL;
    struct stat file_stat;

    /* Skip leading "/upload" from URI to get filename */
    /* Note sizeof() counts NULL termination hence the -1 */
    const char *filename = get_path_from_uri(filepath, ((struct file_server_data *)req->user_ctx)->base_path,
                                             req->uri + sizeof("/upload") - 1, sizeof(filepath));
    if (!filename) {
        /* Respond with 500 Internal Server Error */
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Filename too long");
        return ESP_FAIL;
    }

    /* Filename cannot have a trailing '/' */
    if (filename[strlen(filename) - 1] == '/') {
        ESP_LOGE(TAG, "Invalid filename : %s", filename);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Invalid filename");
        return ESP_FAIL;
    }

    if (stat(filepath, &file_stat) == 0) {
        ESP_LOGE(TAG, "File already exists : %s", filepath);
        /* Respond with 400 Bad Request */
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "File already exists");
        return ESP_FAIL;
    }

    /* File cannot be larger than a limit */
    if (req->content_len > MAX_FILE_SIZE) {
        ESP_LOGE(TAG, "File too large : %d bytes", req->content_len);
        /* Respond with 400 Bad Request */
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST,
                            "File size must be less than "
                            MAX_FILE_SIZE_STR "!");
        /* Return failure to close underlying connection else the
         * incoming file content will keep the socket busy */
        return ESP_FAIL;
    }

    fd = fopen(filepath, "w");
    if (!fd) {
        ESP_LOGE(TAG, "Failed to create file : %s", filepath);
        /* Respond with 500 Internal Server Error */
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to create file");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG, "Receiving file : %s...", filename);

    /* Retrieve the pointer to scratch buffer for temporary storage */
    char *buf = ((struct file_server_data *)req->user_ctx)->scratch;
    int received;

    /* Content length of the request gives
     * the size of the file being uploaded */
    int remaining = req->content_len;

    while (remaining > 0) {

        /* Receive the file part by part into a buffer */
        if ((received = httpd_req_recv(req, buf, MIN(remaining, SCRATCH_BUFSIZE))) <= 0) {
            if (received == HTTPD_SOCK_ERR_TIMEOUT) {
                /* Retry if timeout occurred */
                continue;
            }

            /* In case of unrecoverable error,
             * close and delete the unfinished file*/
            fclose(fd);
            unlink(filepath);

            ESP_LOGE(TAG, "File reception failed!");
            /* Respond with 500 Internal Server Error */
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to receive file");
            return ESP_FAIL;
        }

        /* Write buffer content to file on storage */
        if (received && (received != fwrite(buf, 1, received, fd))) {
            /* Couldn't write everything to file!
             * Storage may be full? */
            fclose(fd);
            unlink(filepath);

            ESP_LOGE(TAG, "File write failed!");
            /* Respond with 500 Internal Server Error */
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to write file to storage");
            return ESP_FAIL;
        }

        /* Keep track of remaining size of
         * the file left to be uploaded */
        remaining -= received;
    }

    /* Close file upon upload completion */
    fclose(fd);
    ESP_LOGI(TAG, "File reception complete");
    /* Redirect onto root to see the updated file list */
    httpd_resp_set_status(req, "303 See Other");
    httpd_resp_set_hdr(req, "Location", FileManagerPrefix);
    httpd_resp_sendstr(req, "File saved successfully");
    return ESP_OK;

}

/* Handler to delete a file from the server */
static esp_err_t delete_post_handler(httpd_req_t *req){
    char filepath[FILE_PATH_MAX];
    struct stat file_stat;

    /* Skip leading "/delete" from URI to get filename */
    /* Note sizeof() counts NULL termination hence the -1 */
    const char *filename = get_path_from_uri(filepath, ((struct file_server_data *)req->user_ctx)->base_path,
                                             req->uri  + sizeof("/delete") - 1, sizeof(filepath));
    if (!filename) {
        /* Respond with 500 Internal Server Error */
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Filename too long");
        return ESP_FAIL;
    }

    /* Filename cannot have a trailing '/' */
    if (filename[strlen(filename) - 1] == '/') {
        ESP_LOGE(TAG, "Invalid filename : %s", filename);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Invalid filename");
        return ESP_FAIL;
    }

    if (stat(filepath, &file_stat) == -1) {
        ESP_LOGE(TAG, "File does not exist : %s", filename);
        /* Respond with 400 Bad Request */
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "File does not exist");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG, "Deleting file : %s", filename);
    /* Delete file */
    unlink(filepath);

    /* Redirect onto root to see the updated file list */
    httpd_resp_set_status(req, "303 See Other");
    httpd_resp_set_hdr(req, "Location", FileManagerPrefix);
    httpd_resp_sendstr(req, "File deleted successfully");
    return ESP_OK;

}

static esp_err_t otaupdate_post_handler(httpd_req_t *req){
    char filepath[FILE_PATH_MAX];
    esp_err_t err;
    /* update handle : set by esp_ota_begin(), must be freed via esp_ota_end() */
    esp_ota_handle_t update_handle = 0 ;
    const esp_partition_t *update_partition = NULL;
    const char *filename = get_path_from_uri(filepath, ((struct file_server_data *)req->user_ctx)->base_path,
                                             req->uri  + sizeof("/otaupdate") - 1, sizeof(filepath));
    if (!filename) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Filename too long");
        return ESP_FAIL;
    }

    /* Filename cannot have a trailing '/' */
    if (filename[strlen(filename) - 1] == '/') {
        ESP_LOGE(TAG, "Invalid filename : %s", filename);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Invalid filename");
        return ESP_FAIL;
    }
    /* Retrieve the pointer to scratch buffer for temporary storage */
    char *buf = ((struct file_server_data *)req->user_ctx)->scratch;
    int received;
    /* Content length of the request gives the size of the file being uploaded */
    int remaining = req->content_len;
    bool image_header_was_checked = false;
    bool FailInWhile = false;
    update_partition = esp_ota_get_next_update_partition(NULL);
    if (update_partition == NULL) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to esp_ota_get_next_update_partition");
        return ESP_FAIL;
    }
    ESP_LOGI(TAG, "Writing to partition subtype %d at offset 0x%"PRIx32,
             update_partition->subtype, update_partition->address);
    while (remaining > 0) {
        received = httpd_req_recv(req, buf, MIN(remaining, SCRATCH_BUFSIZE));
        if (received <= 0) {
            if (received == HTTPD_SOCK_ERR_TIMEOUT) {
                /* Retry if timeout occurred */
                continue;
            }
            /* In case of unrecoverable error */
            ESP_LOGE(TAG, "File reception failed!");
            /* Respond with 500 Internal Server Error */
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to receive file");
            FailInWhile = true;
            break;
        }
        if (!image_header_was_checked) {
            esp_app_desc_t new_app_info;
            if (received > sizeof(esp_image_header_t) + sizeof(esp_image_segment_header_t) + sizeof(esp_app_desc_t)) {
                // check current version with downloading
                memcpy(&new_app_info, &buf[sizeof(esp_image_header_t) + sizeof(esp_image_segment_header_t)], sizeof(esp_app_desc_t));
                char tmpEentry[32];
                strlcpy(tmpEentry, new_app_info.version, sizeof(tmpEentry));
                ESP_LOGI(TAG, "New firmware version: %s", tmpEentry);
                // check project name
                if (memcmp(new_app_info.project_name, SystemInfoData.ProjectName, sizeof(new_app_info.project_name)) != 0) {
                    ESP_LOGW(TAG, "Wrong firmware name. We will not continue the update.");
                    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Wrong firmware name. We will not continue the update.");
                    FailInWhile = true;
                    break;
                }
                // check current version with last invalid partition
                if (memcmp(SystemInfoData.InvalidVersion, new_app_info.version, sizeof(new_app_info.version)) == 0) {
                    ESP_LOGW(TAG, "New version is the same as invalid version.");
                    ESP_LOGW(TAG, "Previously, there was an attempt to launch the firmware with %s version, but it failed.", SystemInfoData.InvalidVersion);
                    ESP_LOGW(TAG, "The firmware has been rolled back to the previous version.");
                    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "New version is the same as invalid version.");
                    FailInWhile = true;
                    break;
                }
                if (memcmp(new_app_info.version, SystemInfoData.RunningVersion, sizeof(new_app_info.version)) == 0) {
                    ESP_LOGW(TAG, "Current running version is the same as a new. We will not continue the update.");
                    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Current running version is the same as a new.");
                    FailInWhile = true;
                    break;
                }
                image_header_was_checked = true;
                err = esp_ota_begin(update_partition, OTA_WITH_SEQUENTIAL_WRITES, &update_handle);
                if (err != ESP_OK) {
                    ESP_LOGE(TAG, "esp_ota_begin failed (%s)", esp_err_to_name(err));
                    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "esp_ota_begin failed");
                    esp_ota_abort(update_handle);
                    FailInWhile = true;
                    break;
                }
                ESP_LOGI(TAG, "esp_ota_begin succeeded");
            } else {
                ESP_LOGE(TAG, "received package is not fit len");
                httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "received package is not fit len");
                FailInWhile = true;
                break;
            }
        }
        err = esp_ota_write(update_handle, (const void *)buf, received);
        if (err != ESP_OK) {
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "esp_ota_write failed");
            esp_ota_abort(update_handle);
            FailInWhile = true;
            break;
        }
        remaining -= received;
    }
    if (FailInWhile) {
        return ESP_FAIL;
    } 
    
    err = esp_ota_end(update_handle);
    if (err != ESP_OK) {
        if (err == ESP_ERR_OTA_VALIDATE_FAILED) {
            ESP_LOGE(TAG, "Image validation failed, image is corrupted");
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Image validation failed, image is corrupted");
        } else {
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "esp_ota_end failed");
            ESP_LOGE(TAG, "esp_ota_end failed (%s)!", esp_err_to_name(err));
        }
        return ESP_FAIL;
    }
    err = esp_ota_set_boot_partition(update_partition);
    if (err != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "esp_ota_set_boot_partition failed");
        ESP_LOGE(TAG, "esp_ota_set_boot_partition failed (%s)!", esp_err_to_name(err));
        return ESP_FAIL;
    }
    ESP_LOGI(TAG, "Prepare to restart system!");
    const int RestartDelay = 10;
    TimerHandle_t  vRestartTimer = xTimerCreate("wifi_tmr", RestartDelay * 1000 / portTICK_PERIOD_MS, pdFALSE, NULL, vRestartCallback);
    xTimerStart(vRestartTimer, 0);
    ESP_LOGI(TAG, "Scheduled restart at %d second", RestartDelay);
    httpd_resp_set_status(req, "303 See Other");
    httpd_resp_set_hdr(req, "Location", "/");
    httpd_resp_sendstr(req, "Flash is complete. Device restarting.");
    return ESP_OK;

}

static esp_err_t NewConfigFileName_post_handler(httpd_req_t *req){
    /* Retrieve the pointer to scratch buffer for temporary storage */
    char *buf = ((struct file_server_data *)req->user_ctx)->scratch;
    char *mBasePath = ((struct file_server_data *)req->user_ctx)->base_path;
    int received;
    char FullFileName[FILE_PATH_MAX];
    struct stat file_stat;
    nvs_handle_t HCNVSHandle;

    /* Content length of the request gives the size of the file being uploaded */
    size_t base_pathlen = strlen(mBasePath);
    if (req->content_len >= FILE_PATH_MAX - base_pathlen) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Filename too long");
        return ESP_FAIL;
    }
    received = httpd_req_recv(req, buf, req->content_len);
    if (received != req->content_len) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to receive file name");
        return ESP_FAIL;
    }
    strcpy(FullFileName, mBasePath);
    FullFileName[base_pathlen] = '/';
    strlcpy(FullFileName + base_pathlen + 1, buf, received + 1);
    if (stat(FullFileName, &file_stat) == -1) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "File does not exist");
        return ESP_FAIL;
    }
    if (LoadControlConfig(FullFileName) != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Errors in LoadControlConfig");
        return ESP_FAIL;
    }
    // store FileName in NVS
    if (nvs_open(NVS_Namespace, NVS_READWRITE, &HCNVSHandle) != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Cannot open NVS for save data");
        return ESP_FAIL;
    }
    if (nvs_set_str(HCNVSHandle, KeyConfigFile, FullFileName) != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Cannot save data in NVS");
        return ESP_FAIL;
    };
    nvs_commit(HCNVSHandle);
    nvs_close(HCNVSHandle);
    if (ConfigFileName != NULL) free(ConfigFileName);
    ConfigFileName = strdup(FullFileName);
    /* Redirect onto root to see the updated file list */
    httpd_resp_set_status(req, "303 See Other");
    httpd_resp_set_hdr(req, "Location", "/");
    httpd_resp_sendstr(req, "File saved, configuration updated.");
    return ESP_OK;

}

esp_err_t Start_HTTP_Server(){
    if (server_data) {
        ESP_LOGE(TAG, "File server already started");
        return ESP_ERR_INVALID_STATE;
    }
    /* Allocate memory for server data */
    server_data = malloc(sizeof(struct file_server_data));
    if (!server_data) {
        ESP_LOGE(TAG, "Failed to allocate memory for server data");
        return ESP_ERR_NO_MEM;
    }
    strlcpy(server_data->base_path, SpiffsBasePath,
            sizeof(server_data->base_path));
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    /* Use the URI wildcard matching function in order to
     * allow the same handler to respond to multiple different
     * target URIs which match the wildcard scheme */
    config.uri_match_fn = httpd_uri_match_wildcard;
    ESP_LOGI(TAG, "Starting HTTP Server on port: '%d'", config.server_port);
    if (httpd_start(&HCHTTPServer, &config) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start file server!");
        return ESP_FAIL;
    }
    ESP_LOGI(TAG, "HTTP Server started. Registering handlers...");
    /* URI handler for getting uploaded files */
    httpd_uri_t file_download = {
        .uri       = "/*",  // Match all URIs of type /path/to/file
        .method    = HTTP_GET,
        .handler   = download_get_handler,
        .user_ctx  = server_data    // Pass server data as context
    };
    httpd_register_uri_handler(HCHTTPServer, &file_download);
    /* URI handler for uploading files to server */
    httpd_uri_t file_upload = {
        .uri       = "/upload/*",   // Match all URIs of type /upload/path/to/file
        .method    = HTTP_POST,
        .handler   = upload_post_handler,
        .user_ctx  = server_data    // Pass server data as context
    };
    httpd_register_uri_handler(HCHTTPServer, &file_upload);
    /* URI handler for deleting files from server */
    httpd_uri_t file_delete = {
        .uri       = "/delete/*",   // Match all URIs of type /delete/path/to/file
        .method    = HTTP_POST,
        .handler   = delete_post_handler,
        .user_ctx  = server_data    // Pass server data as context
    };
    httpd_register_uri_handler(HCHTTPServer, &file_delete);
    /* URI handler for upload for ota update */
    httpd_uri_t file_otaupdate = {
        .uri       = "/otaupdate/*",   // Match all URIs of type /otaupdate/path/to/file
        .method    = HTTP_POST,
        .handler   = otaupdate_post_handler,
        .user_ctx  = server_data    // Pass server data as context
    };
    httpd_register_uri_handler(HCHTTPServer, &file_otaupdate);
    /* URI handler for upload for config file name update */
    httpd_uri_t NewConfigFileName = {
        .uri       = "/NewConfigFileName",   // Match URIs of type /NewConfigFileName
        .method    = HTTP_POST,
        .handler   = NewConfigFileName_post_handler,
        .user_ctx  = server_data    // Pass server data as context
    };
    httpd_register_uri_handler(HCHTTPServer, &NewConfigFileName);
    ESP_LOGI(TAG, "HTTP handlers registered");
    return ESP_OK;

}

esp_err_t Stop_HTTP_Server(){
    esp_err_t ret=ESP_OK;
    if (HCHTTPServer){
        httpd_unregister_uri_handler(HCHTTPServer, "/NewConfigFileName", HTTP_POST);    // NewConfigFileName   
        httpd_unregister_uri_handler(HCHTTPServer, "/otaupdate/*", HTTP_POST);          // file_otaupdate   
        httpd_unregister_uri_handler(HCHTTPServer, "/delete/*", HTTP_POST);             // file_delete 
        httpd_unregister_uri_handler(HCHTTPServer, "/upload/*", HTTP_POST);             // file_upload 
        httpd_unregister_uri_handler(HCHTTPServer, "/*", HTTP_GET);                     // file_download
        ESP_LOGD(TAG, "HTTP handlers unregistered. Stopping server...");
        ret = httpd_stop(HCHTTPServer);
        HCHTTPServer = NULL;
        ESP_LOGI(TAG, "HTTP server stopped");
    }
    if (server_data){
        free(server_data);
        server_data = NULL;
        ESP_LOGI(TAG, "HTTP server data freed");
    }
    return ret;

}

bool SelectWiFiAP(wifi_config_t *WiFiConfig){
    wifi_ap_record_t *ArrayAPInfo;
    uint16_t ap_count = 0;
    int8_t SelectedAP = -1;
    ESP_ERROR_CHECK(esp_wifi_scan_get_ap_num(&ap_count));
    if (ap_count > 0) {
        ArrayAPInfo = malloc(ap_count * sizeof(wifi_ap_record_t));
        ESP_RETURN_ON_FALSE(ArrayAPInfo != NULL, false, TAG, "no mem for ArrayAPInfo data");                    
        ESP_ERROR_CHECK(esp_wifi_scan_get_ap_records(&ap_count, ArrayAPInfo));
        for (int i = 0; i < ap_count; i++) {
            for (int y=0; (y < 3) && (SelectedAP == -1); y++){
                if (strcmp((char*)ArrayAPInfo[i].ssid, AccessPoints[y][0]) == 0) {
                    SelectedAP = y;
                }
            }
            ESP_LOGD(TAG, "SSID \t\t%s", ArrayAPInfo[i].ssid);
            ESP_LOGD(TAG, "RSSI \t\t%d", ArrayAPInfo[i].rssi);
        }
        free(ArrayAPInfo);
    }
    if (SelectedAP == -1){
        ESP_LOGW(TAG, "Cannot find famous access points. Total APs scanned: %u", ap_count);
        return false;
    } else {
        ESP_LOGI(TAG, "Found AP SSID %s", AccessPoints[SelectedAP][0]);
        bzero(WiFiConfig, sizeof(wifi_config_t));
        memcpy(WiFiConfig->sta.ssid, AccessPoints[SelectedAP][0], strlen(AccessPoints[SelectedAP][0]));
        memcpy(WiFiConfig->sta.password, AccessPoints[SelectedAP][1], strlen(AccessPoints[SelectedAP][1]));
        WiFiConfig->sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;
        return true;
    }

}

static void vTimerCallback(TimerHandle_t tmr){
    if (NumberAttempt == HC_MaxWIFIReconnectAttempts) {
        esp_wifi_disconnect();
        wifi_config_t WiFiStaCfg;
        bzero(&WiFiStaCfg, sizeof(wifi_config_t));
        WiFiStaCfg.sta.sort_method = WIFI_CONNECT_AP_BY_SIGNAL;
        WiFiStaCfg.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;
        esp_wifi_set_config(WIFI_IF_STA, &WiFiStaCfg);
        esp_wifi_scan_start(NULL, false);
    } else 
        esp_wifi_connect();

}

static void ConfirmOtaUpdate(void){
    const esp_partition_t *running = esp_ota_get_running_partition();
    esp_ota_img_states_t ota_state;
    if (esp_ota_get_state_partition(running, &ota_state) == ESP_OK) {
        if (ota_state == ESP_OTA_IMG_PENDING_VERIFY || ota_state == ESP_OTA_IMG_VALID
            || ota_state == ESP_OTA_IMG_UNDEFINED) {
            hc_Status &= ~HC_STATUS_BIT_OTA;
            if (ota_state == ESP_OTA_IMG_PENDING_VERIFY){
                ESP_LOGI(TAG, "Confirm OTA update! Continuing execution ...");
                esp_ota_mark_app_valid_cancel_rollback();
            }
        }
    }

}

void ReconnectingProcess(void){
    hc_Status |= HC_STATUS_BIT_WIFI;
    // reconnecting process
    unsigned int TimerPeriod = 1 << NumberAttempt;
    if (NumberAttempt < HC_MaxWIFIReconnectAttempts) 
        NumberAttempt ++; 
    if (!(hc_Status & HC_STATUS_BIT_HTTP) && NumberAttempt == HC_MaxWIFIReconnectAttempts - 1) {
        // must stop web server and other socket applications. If they are running
        ESP_ERROR_CHECK(Stop_HTTP_Server());
        hc_Status |= HC_STATUS_BIT_HTTP;
        esp_sntp_stop();
    }
    if(WifiReconnectTimer == NULL){
        WifiReconnectTimer = xTimerCreate("wifi_tmr", TimerPeriod * 1000 / portTICK_PERIOD_MS, pdFALSE, NULL, vTimerCallback);
        if(WifiReconnectTimer != NULL) xTimerStart(WifiReconnectTimer, 0);
    }else{
        if(xTimerIsTimerActive(WifiReconnectTimer) == pdFALSE){
            xTimerChangePeriod(WifiReconnectTimer, TimerPeriod * 1000 / portTICK_PERIOD_MS, 0); 
        }
    }
    ESP_LOGI(TAG, "Scheduled reconnect at %d second", TimerPeriod);

}

static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){
    wifi_config_t WiFiStaConfig;
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        ESP_ERROR_CHECK(esp_wifi_get_config(WIFI_IF_STA, &WiFiStaConfig));
        if (WiFiStaConfig.sta.ssid[0] == 0) {
            ESP_ERROR_CHECK(esp_wifi_scan_start(NULL, false));
        } else {
            ESP_LOGI(TAG, "Stored SSID: %s, connecting...", WiFiStaConfig.sta.ssid);
            ESP_ERROR_CHECK(esp_wifi_connect());
        }
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_SCAN_DONE) {
        if (SelectWiFiAP(&WiFiStaConfig)) {
            ESP_ERROR_CHECK(esp_wifi_disconnect());
            ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &WiFiStaConfig));
            ESP_ERROR_CHECK(esp_wifi_connect());
        } else {
            NumberAttempt = HC_MaxWIFIReconnectAttempts;
            ReconnectingProcess();
        }
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        ReconnectingProcess();
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        hc_Status &= ~HC_STATUS_BIT_WIFI;
        NumberAttempt = 0;
        // check if address changed
        if (event->ip_changed && !(hc_Status & HC_STATUS_BIT_HTTP)) {
            ESP_ERROR_CHECK(Stop_HTTP_Server());
            hc_Status |= HC_STATUS_BIT_HTTP;
            esp_sntp_stop();
        }
        // start web server and other socket applications 
        if (hc_Status & HC_STATUS_BIT_HTTP) {
            ESP_ERROR_CHECK(Start_HTTP_Server());
            hc_Status &= ~HC_STATUS_BIT_HTTP;
            initialize_sntp();
        }
        // check ota update
        if (hc_Status & HC_STATUS_BIT_OTA) ConfirmOtaUpdate();
    } else if (event_base == ESP_HTTP_SERVER_EVENT && event_id == HTTP_SERVER_EVENT_ON_CONNECTED ){
        int *SocketDescriptor = (int*) event_data;
        //char IpStr6[INET6_ADDRSTRLEN];
        char IpStr4[INET_ADDRSTRLEN];
        struct sockaddr_in6 Address6;
        socklen_t SizeAddress6 = sizeof(Address6);
        if (getpeername(*SocketDescriptor, (struct sockaddr *)&Address6, &SizeAddress6) < 0){
            ESP_LOGE(TAG, "Error getting client IP in new session (HTTP_SERVER_EVENT_ON_CONNECTED)");
        } else {
            //inet_ntop(AF_INET6, &Address6.sin6_addr, IpStr6, sizeof(IpStr6));
            inet_ntop(AF_INET, &Address6.sin6_addr.un.u32_addr[3], IpStr4, sizeof(IpStr4));
            //ESP_LOGI(TAG, "Got connect from host: %s (%s)", IpStr6, IpStr4);
            ESP_LOGI(TAG, "New http session from: %s", IpStr4);
        }
    }
}

esp_err_t mount_storage(const char* base_path){
    esp_vfs_spiffs_conf_t conf = {
        .base_path = base_path,
        .partition_label = NULL,
        .max_files = 3,   // This sets the maximum number of files that can be open at the same time
        .format_if_mount_failed = true
    };
    esp_err_t ret = esp_vfs_spiffs_register(&conf);
    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE(TAG, "Failed to mount or format filesystem");
        } else if (ret == ESP_ERR_NOT_FOUND) {
            ESP_LOGE(TAG, "Failed to find SPIFFS partition");
        } else {
            ESP_LOGE(TAG, "Failed to initialize SPIFFS (%s)", esp_err_to_name(ret));
        }
        return ret;
    }
    size_t total = 0, used = 0;
    ret = esp_spiffs_info(NULL, &total, &used);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to get SPIFFS partition information (%s)", esp_err_to_name(ret));
        return ret;
    }
    ESP_LOGI(TAG, "Partition '%s' registered, Size: total: %d, used: %d", base_path, total, used);
    return ESP_OK;

}

void sayStatus(void *VoidParam){   
    uint8_t BlinkCounter;
    int16_t BlinkPeriod;
    while (true){
        if(hc_Status & HC_STATUS_BIT_INIT) {
            BlinkCounter=10;
            BlinkPeriod=100;
        }else{
            BlinkPeriod=200;
            if(hc_Status & HC_STATUS_BIT_HTTP) BlinkCounter=2;
            else if(hc_Status & HC_STATUS_BIT_WIFI) BlinkCounter=1;
            else{
                BlinkCounter=1;
                BlinkPeriod=2000;
            }
        }
        for (uint8_t i = 0; i < BlinkCounter; i++){
            for (uint8_t u=0; u<2; u++){
                gpio_set_level(BLINK_GPIO, !u);
                vTaskDelay(BlinkPeriod / portTICK_PERIOD_MS);
            }
        }
        vTaskDelay(hc_sayStatusPeriod / portTICK_PERIOD_MS);
    }
}

int LogToRingBuffer(const char *fmt, va_list args){
    const size_t MaxMsgLen = 254;
    static char BufferString[254];
    static char MessageString[254];
    static _lock_t bufferLock = 0;
    char MonthAndDay[21];
    char *OpenBracket;
    int LenMessage;
    struct timeval tv;
    struct tm timeinfo;
    _lock_acquire(&bufferLock);
    LenMessage = vsnprintf(BufferString, MaxMsgLen - 1, fmt, args);
    if (LenMessage>=0) {
        OpenBracket = strchr(BufferString, '(');
        if (OpenBracket) {
            strncpy(MessageString, BufferString, OpenBracket - BufferString + 1);
            MessageString[OpenBracket - BufferString + 1] = '\0';
            gettimeofday(&tv, NULL);
            localtime_r(&tv.tv_sec, &timeinfo);
            strftime(MonthAndDay, sizeof(MonthAndDay), "%F %T ", &timeinfo);
            strcat(MessageString, MonthAndDay);
            strcat(MessageString + strlen(MonthAndDay), OpenBracket + 1);
            RingBufferPut(&HCLogBuffer, MessageString, strlen(MessageString));
        } else {
            RingBufferPut(&HCLogBuffer, BufferString, LenMessage);
        }
    }
#ifdef HC_SHOWLOG
    printf("%s", BufferString);
#endif
    _lock_release(&bufferLock);
    return LenMessage;
    
}

static void uninitializeCtrl(void)
{
    if (WifiReconnectTimer != NULL) xTimerDelete(WifiReconnectTimer, 0);
    if (TemperatureReaderHandle != NULL) vTaskDelete(TemperatureReaderHandle);
    hc_CurrentError = Stop_HTTP_Server();
    hc_Status |= HC_STATUS_BIT_HTTP;
    esp_sntp_stop();
    ClearConfiguredControls();
    ClearConfiguredDevices();
    if (ConfigFileName != NULL) {
        free(ConfigFileName);
        ConfigFileName = NULL;
    }
    esp_netif_destroy_default_wifi(NetworkInterface);
    hc_Status |= HC_STATUS_BIT_WIFI;
    onewire_bus_del(OWBus);
    OWBus = NULL;
    esp_vfs_spiffs_unregister(NULL);
    esp_event_loop_delete_default();
    nvs_flash_deinit();
    if (TaskSayStatusHandle != NULL) vTaskDelete(TaskSayStatusHandle);
    TaskSayStatusHandle = NULL;
    RingBufferDestroy(&HCLogBuffer);

}

void app_main(void){
#ifdef HC_SHOWLOG
    esp_log_level_set(TAG, ESP_LOG_DEBUG);
#else
    esp_log_level_set(TAG, ESP_LOG_INFO);
#endif
    // esp_log_level_set("wifi_init", ESP_LOG_INFO);
    // esp_log_level_set("wifi", ESP_LOG_INFO);
    RingBuffer_mux = xSemaphoreCreateMutex();
    RingBufferCreate(&HCLogBuffer, 1024 * 32 - 1); // initial size 32K
    LogFuncOriginal = esp_log_set_vprintf(LogToRingBuffer);
    // Configure pin led
    gpio_reset_pin(BLINK_GPIO);
    hc_CurrentError=gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
    // Start blinker
    xTaskCreate(sayStatus, "sayStatus", 1024, NULL, tskIDLE_PRIORITY, &TaskSayStatusHandle);
    // Configure control load pins and set to Off
    for (int i = 0; i < MAX_DEVICES; i++) {
        gpio_reset_pin(OutputGPIO[i]);
        gpio_set_direction(OutputGPIO[i], GPIO_MODE_OUTPUT);
        gpio_set_level(OutputGPIO[i], HC_CONTROLLEVEL_LO);
    } 
    // Initialize default NVS psrtition
    hc_CurrentError = nvs_flash_init();
    if (hc_CurrentError == ESP_ERR_NVS_NO_FREE_PAGES || hc_CurrentError == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      hc_CurrentError = nvs_flash_init();
    }
    ESP_ERROR_CHECK(hc_CurrentError);
    // Initialize esp event subsystem
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    // Initialize file storage 
    ESP_ERROR_CHECK(mount_storage(SpiffsBasePath));
    //Initialize tcp/ip stack
    ESP_ERROR_CHECK(esp_netif_init());
    // Read partition information
    const esp_partition_t *configured = esp_ota_get_boot_partition();
    const esp_partition_t *running = esp_ota_get_running_partition();
    const esp_partition_t *last_invalid_app = esp_ota_get_last_invalid_partition();
    esp_app_desc_t running_app_info;
    esp_app_desc_t invalid_app_info;
    SystemInfoData.PartRunnAddr = running->address;
    SystemInfoData.PartConfAddr = configured->address;
    if (esp_ota_get_partition_description(running, &running_app_info) == ESP_OK) {
        memcpy(SystemInfoData.RunningVersion, running_app_info.version, sizeof(running_app_info.version));
        memcpy(SystemInfoData.ProjectName, running_app_info.project_name, sizeof(running_app_info.project_name));
    }
    if (esp_ota_get_partition_description(last_invalid_app, &invalid_app_info) == ESP_OK) {
        memcpy(SystemInfoData.InvalidVersion, invalid_app_info.version, sizeof(invalid_app_info.version));
    }
    // Initialize one wire bus
    ESP_ERROR_CHECK(onewire_new_bus_rmt(&OWBus_config, &OWRmt_config, &OWBus));
    ESP_LOGI(TAG, "1-Wire bus installed on GPIO%d", GPIO_ONE_WIRE);
    //Initialize WiFi station
    NetworkInterface = esp_netif_create_default_wifi_sta();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID,  &wifi_event_handler, NULL, NULL));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_event_handler, NULL, NULL));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(ESP_HTTP_SERVER_EVENT, HTTP_SERVER_EVENT_ON_CONNECTED, &wifi_event_handler, NULL, NULL));
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    // Read MAC address from wifi interface
    esp_wifi_get_mac(WIFI_IF_STA, SystemInfoData.MacAddress);
    SystemInfoData.HostName=CONFIG_LWIP_LOCAL_HOSTNAME;
    // Get config file name and load it
    nvs_handle_t HCNVSHandle;
    size_t StringSize = 0;
    ControlDSData_mux = xSemaphoreCreateMutex();
    hc_CurrentError = nvs_open(NVS_Namespace, NVS_READONLY, &HCNVSHandle);
    if (hc_CurrentError == ESP_ERR_NVS_NOT_FOUND){
        ESP_LOGW(TAG, "Namespace %s not found in NVS", NVS_Namespace);
    } else if (hc_CurrentError == ESP_OK) {
        hc_CurrentError = nvs_get_str(HCNVSHandle, KeyConfigFile, NULL, &StringSize);
        if (hc_CurrentError != ESP_OK && hc_CurrentError != ESP_ERR_NVS_NOT_FOUND) ESP_ERROR_CHECK(hc_CurrentError);
        if (StringSize == 0) {
            ESP_LOGW(TAG, "Config file name not stored in NVS");
        } else {
            ConfigFileName = malloc(StringSize);
            hc_CurrentError = nvs_get_str(HCNVSHandle, KeyConfigFile, ConfigFileName, &StringSize);
            if (hc_CurrentError != ESP_OK) {
                free(ConfigFileName);
                ConfigFileName = NULL;
                nvs_close(HCNVSHandle);
                ESP_ERROR_CHECK(hc_CurrentError);
            }
            nvs_close(HCNVSHandle);
            //Read config file
            hc_CurrentError = LoadControlConfig(ConfigFileName);
        }
    } else {
        ESP_ERROR_CHECK(hc_CurrentError);
    }
    // Search one wire devices, in not found in LoadControlConfig function
    if (ConfigFileName == NULL && num_devices == 0) ESP_ERROR_CHECK(SearchOWDevices(OWBus));
    // Start the file server called from wifi_event_handler
    ESP_ERROR_CHECK(esp_wifi_start());
    // Start task for read temperature
    if (xTaskCreate(ReadTemperatures, "ReadTemp", 1024*3, NULL, tskIDLE_PRIORITY, &TemperatureReaderHandle) != pdPASS)
       ESP_LOGE(TAG, "Error create task ReadTemperatures");
    hc_Status &= ~HC_STATUS_BIT_INIT;
    ESP_LOGI(TAG, "Initialize finished");
    // Check OTA updates after pause 10 sec for got ip address and start HTTP server
    vTaskDelay(10000 / portTICK_PERIOD_MS);
    esp_ota_img_states_t ota_state;
    if (esp_ota_get_state_partition(running, &ota_state) == ESP_OK) {
        if (ota_state == ESP_OTA_IMG_PENDING_VERIFY) {
            hc_Status &= ~HC_STATUS_BIT_OTA;
            ESP_LOGE(TAG, "OTA check timed out! Start rollback to the previous version ...");
            esp_ota_mark_app_invalid_rollback_and_reboot();
        }
    }
    // Check and correct not found sensors
    for (int i = 0; i < MAX_DEVICES; i++) {
        if (ConfigFileName != NULL && NotFoundSensorCount > 0) {
            i++;
            vTaskDelay(5000 * i / portTICK_PERIOD_MS);
            ESP_LOGI(TAG, "Next attempt (%d) to load config file.", i);
            hc_CurrentError = LoadControlConfig(ConfigFileName);
        } else break;
    }
    ESP_ERROR_CHECK(esp_register_shutdown_handler(&uninitializeCtrl));
    ESP_LOGI(TAG, "Startup complete");
    // Test disconnect
    // vTaskDelay(5000 / portTICK_PERIOD_MS);
    // ESP_LOGI(TAG, "uninitializeCtrl();");
    // uninitializeCtrl();

}
